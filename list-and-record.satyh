@import: settings

let list-and-record = '<
    +p{
      \ref-section(`Other data`);で少しだけ紹介しましたが、
      本章では\dfn{リスト}と\dfn{レコード}について詳しく説明します。
      リストやレコードは、これまで紹介したような基本的なデータと型やタプルでは表現しきれなかったデータ構造を表すために利用できます。
    }
    +section?:(`List`){リスト}<
      +p{
        リストは、同じ型を持つ全ての要素が任意の個数並んだデータのことです。
        タプルでは特定の値の並びしか定義できませんでしたが、リストは型が同じでさえあれば要素を好きなだけ並べることができます。

        リストを作成するには以下の構文を利用します。

        \d-code(```
          [ <expr>; ... ]
        ```);%

        \codem{\<expr\>}はこれまで見てきた通り式を表します。この\codem{\<expr\>}を\codem{\;}で区切り、
        \codem{[}と\codem{]}で囲むことでリストを生成できます。
        間の3つのドット（\codem{...}）は「後ろに2番目の要素、3番目の要素...のように0個以上の要素を取って良い」ことを示します。
        
        utopにて、整数のリストを表現する例を示します。

        \d-code(```
          utop # [1; 2; 3;] ;;
          - : int list = [1; 2; 3]
        ```);%

        なお、リストの末尾の要素を区切るための\codem{\;}は省略できます。

        \d-code(```
          utop # [1; 2; 3] ;;
          - : int list = [1; 2; 3]
        ```);%

        前述したように、リストの要素は全て同じ型でなければいけません。

        \d-code(```
          utop # [1; "two"; 3] ;;
          Line 1, characters 4-9:
          Error: This expression has type string but an expression was expected of type
                   int
        ```);%

        上記のエラーは、「リストの要素にstring型が含まれているが、期待したものはint型である」旨が示されています。
      }
      +p{
        また、要素を1つも持たないリストを\dfn{空リスト}または\dfn{空のリスト}といいます。
        空リストは\codem{[]}で表現します。

        \d-code(```
          utop # [] ;;
          - : 'a list = []
        ```);%

        空リストは要素を持たないため、要素の型をこの時点で決定できないため、要素の型は多相型\codem{'a}となっています。
        そして、このリストの型は\codem{'a list}となります。
      }
      +p{
        OCamlでは、リストの先頭に要素を追加するため
        （正確には、リストの先頭にある要素を追加した結果を得るため）\codem{::}を利用します。
        \codem{::}はリストを構成するための\dfn{コンストラクタ}\footnote{
          OCamlにおけるコンストラクタとは、何らかの型（\ref-section(`Variants`);で説明します）の値を生成するものを指します。
          ここでは、短く「型の値を生成するためのもの」という解釈で構いません。
        }、
        で、\dfn{コンス（\codem{cons}）}と呼ばれます。
        \codem{::}が関数ではないことに注意して下さい。
        そのため、\ref-chapter(`Basic data and types`);で見たような演算子、
        例えば\codem{+、-、\*、/}のように引数を取るような形で書くことができません。
        つまり、関数であれば

        \d-code(```
          utop # (+) 4 3 ;;
          - : int = 7

          utop # (-) 5 3 ;;
          - : int = 2
        ```);%

        のようにできるのですが、\codem{::}はコンストラクタのため上記のように記述することができないことに注意して下さい。
        実際に\codem{::}を利用して整数1つを空リストに追加する例を見てみます。

        \d-code(```
          utop # 3 :: [] ;;
          - : int list = [3]
        ```);%

        上記の結果\codem{[3]}という整数\codem{3}だけを持つリストが生成できました。
        空リストは\codem{'a list}で、多相型を要素として持つ\dfn{多相リスト}であるため、あらゆる型を持つことができます。
        コンスがリストの先頭に同じ型を持つ要素を追加することによってリストの値（上記の例では\codem{[3]}）を得られたことから、
        次のように複数の要素を一度に追加できることが分かります。

        \d-code(```
          utop # 5 :: 4 :: 3 :: [] ;;
          - : int list = [5; 4; 3]
        ```);%

        コンスは右結合であるため、上記の例は

        \d-code(```
          utop # 5 :: (4 :: (3 :: [])) ;;
          - : int list = [5; 4; 3]
        ```);%

        と同じになります。
        これまでは空リストに値を追加するためにコンスを利用する例を見てきましたが、
        すでに要素を持つリストに対しても利用することができます。

        \d-code(```
          utop # 5 :: [4; 3] ;;
          - : int list = [5; 4; 3]
        ```);%

        このことは、\codem{5 :: (4 :: (3 :: []))}からも明白ですね。
      }
      +subsection{リストとパターンマッチ}<+p{
        パターンマッチ\codem{match...with...}を利用して、リストの要素を参照することができます。

        ここでパターンマッチの構文をおさらいします。

        \d-code(```
          match <expr0> with
          | <pattern1> -> <expr1>
          | <pattern2> -> <expr2>
          | ...
          | <pattern_n> -> <expr_n>
        ```);%

        構文の表現が\ref-subsection(`Match expression`);のものと若干異なりますが、内容は同じものを示しています。
        \codem{...}で省略していた部分を少し詳細に書いたものになります。

        ただし、リストにパターンマッチを適用するには、必ず空リスト\codem{[]}にマッチするパターンを書く必要があります。
        具体的には、次のような形になります。

        \d-code(```
          match <expr0> with
          | [] -> <expr1>
          | <pattern2> -> <expr2>
          | ...
          | <pattern_n> -> <expr_n>
        ```);%
        
        パターンマッチを用いて、リストの最初の要素を取り出す例を考えてみます。        

        \d-code(```
          utop # match [3; 4; 5] with
            | [] -> 0
            | first :: rest -> first ;;
          - : int = 3
        ```);%

        ここで、\codem{first}は\codem{3}にマッチし、\codem{rest}は\codem{[4\; 5]}にマッチします。 
        \codem{[3\; 4\; 5]}というのは、\codem{3 :: [4\; 5]}と同じであることを考えると、
        \codem{first}に\codem{3}がマッチし、\codem{rest}が\codem{[4\; 5]}にマッチすることが分かります。

        もちろん、match式に空リストを渡すと0が返ります。

        \d-code(```
          utop # match [] with
            | [] -> 0
            | first :: rest -> first ;;
            - : int = 0
        ```);%

        また、先程の例では\codem{rest}を利用してなかったため、
        ワイルドカード\codem{_}を利用して、次のように書き換える方が実際の実装としては望ましいでしょう。

        \d-code(```
          utop # match [3; 4; 5] with
            | [] -> 0
            | first :: _ -> first ;;
          - : int = 3
        ```);%
      }
      +p{
        ここで、仮に空リストのパターンを書かなかった場合はどうなるでしょうか。

        \d-code(```
          utop # match [3; 4; 5] with
            | first :: rest -> first ;;
          Lines 1-2, characters 0-26:
          Warning 8 [partial-match]: this pattern-matching is not exhaustive.
          Here is an example of a case that is not matched:
          []
          - : int = 3
        ```);%

        警告が発生しましたが、リストの先頭要素である\codem{3}は返されています。
        この警告は、「パターンマッチにおいて全てのパターンが網羅されおらず、\codem{[]}のパターンにマッチしない」ことを表しています。
        この逆で、パターンマッチに空リストを渡し、空リストにのみマッチするパターンを書いた場合も同様に警告が発生します。

        \d-code(```
          utop # match [] with
            | [] -> 0 ;;
          Lines 1-2, characters 0-11:
          Warning 8 [partial-match]: this pattern-matching is not exhaustive.
          Here is an example of a case that is not matched:
          _::_
          - : int = 0
        ```);%

        ただし先程の警告とは異なり、マッチしないパターンが\codem{_::_}となっています。
        これはリストの長さが1以上のものにマッチするパターンがないことを表しています。

        インタプリタはリストに要素がある場合とそうでない（空リストの）場合があることを知っており、
        パターンマッチが網羅的でない場合にどのようなパターンの漏れがあるかを出力してくれます。
      }
      +p{
        逆にマッチするパターンを書かなかった場合はどうなるでしょうか。
        例えば、空リストを渡すにも関わらず、空リストに対するパターンが記載されない場合です。

        \d-code(```
          utop # match [] with
            | first :: rest -> first ;;
          Warning 8 [partial-match]: this pattern-matching is not exhaustive.
          Here is an example of a case that is not matched:
          []
          Exception: Match_failure ("//toplevel//", 1, 0).
        ```);%

        エラー（正確には\dfn{例外}）が発生しました。
        例外は\codem{Match_failure}であり、
        これは、「パターンマッチを適用したが該当するパターンが見つからなかった」ことを示しています。
        
      }
      >
    >
    +section?:(`Record`){レコード}<
      +p{
        タプルでは要素の順序を意識する必要がありました。
        しかし、扱うデータによっては要素の順番を意識する必要がなかったり、
        そもそも要素の順番が一定でないデータもあります。
        またタプルには、各要素の値が何を表しているかといった、要素に対する名称をつけることができませんでした。
        そのような場合は、レコードを利用することで、
        要素の順番を気にせず且つ要素に対する名称を与えることができます。

        レコードを利用するには以下の構文を利用します。

        \d-code(```
          {
            <field> = <value> ;
            ...
          }
        ```);%

        \codem{\<field\>}がレコードの要素名を表し、\codem{\<value\>}がその要素の値を表します。
        なお、レコードではこの要素名のことを\dfn{フィールド}といいます。
      }
      +p{
        ここで注意点があります。
        レコードを利用するには、まずレコードの型を定義し、
        その後で（前述したような）レコードを利用するための構文を使う必要があります。
        そこで、まずはレコードを定義するための構文を確認します。
        レコードの新しい型を定義するには、以下の構文を利用します。

        \d-code(```
          type <record> = {
            <field> : <type> ;
            ...
          }
        ```);%

        上記の構文において、\codem{\<record\>}は定義する型名を表しています。そして型名に続く\codem{\{...\}}の中に、
        レコードのフィールド名\codem{\<field\>}、コロン（\codem{:}）、フィールド名の型\codem{\<type\>}、
        レコードの末尾を表すセミコロン（\codem{\;}）の順で記述します。
        \codem{\{\}}中の3つのドット（\codem{...}）は「後ろに\codem{\<field\> : \<type\> \;}...形をした別名のフィールドを書いて良い」ことを示します。

        なお、全てのフィールド名は小文字で始まる必要があります。
        さらに、フィールド名はその型定義の中で一意でなければなりません。
        つまり、重複するようなフィールド名を持つことはできません。
        以下に、重複したフィールド名を定義した場合の例を示します。

        \d-code(```
          utop # type profile = {
            name : string ;
            name : int ;
          } ;;
          Line 3, characters 2-6:
          Error: Two labels are named name
        ```);%
        上記の例では、\codem{profile}というレコード型を定義しようとしていますが、
        エラーには「\codem{name}という名称が2つ存在する」ことが示されています。
      }
      +p{
        また、レコードに限らず独自の型を定義する場合にも\codem{type}キーワードを利用できます。
        独自の型を定義するには以下の構文を使います。

        \d-code(```
          type <type> = <def>
        ```);%

        \codem{\<typ\>}は型名を表し、\codem{\<def\>}は型定義を表します。
        これは前述したレコードの型を定義する構文と一致していることが分かります。
      }
      +p{
        ここで、個人情報を扱うためのデータとしてレコードを利用する例を考えてみます。
        レコードには、氏名と年齢を個人情報として持つように設計したとすると、以下のように定義できます。

        \d-code(```
          utop # type personal_info = {
            name : string ;
            age  : int ;
          } ;;
          type personal_info = { name : string; age : int; }
        ```);%
        
        上記の例では、string型で表現される\codem{name}フィールドと、
        int型で表現される\codem{age}フィールドから構成される、\codem{personal_info}という型を定義しています。
      }
    >
    +section?:(`Practice of list and record`){実践}<
      +p{
        https://dev.realworldocaml.org/records.htmlを書く
      }
    >
>