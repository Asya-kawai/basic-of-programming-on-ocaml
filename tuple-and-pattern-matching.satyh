@import: settings

let tuple-and-pattern-matching = '<
    +p{
      \ref-chapter(`Conditional branch`);にて、if式を用いた条件分岐について説明しました。
      if式は条件部分にbool型を取ることで条件分岐を行い、then節及びelse節のどちらか一方を実行するものでしたが、
      より複雑なパターンやそれに応じた分岐を扱いたい場合もあります。
      本章では、より複雑なパターンの表現方法やそれを用いた分岐について説明します。
    }
    +section?:(`Tuple`){タプル}<
      +p{
        \dfn{タプル}（Tuple）は1つ以上のデータ（要素）を並べてひとまとめのデータにしたものです。
        別の言い方をすれば、タプルはそれぞれ異なる型の値を順序付けて並べたコレクションです。

        OCamlにおいて、タプルは値をカンマ（\codem{,}）で区切って表現します。

        \d-code(```
          utop # (1, "one") ;;
          - : int * string = (1, "one")
        ```);%

        タプルの型（tuple型）は、各要素の型をアスタリスク（\codem{\*}）でつないだものになります。
        上記の例では、int型とstring型を要素として持つタプルを定義しています。
        タプルはデータであるため、整数や実数のように変数にバインドできます。

        \d-code(```
          utop # let tuple = (1, "one") ;;
          val tuple : int * string = (1, "one")
        ```);%

        また、タプルは要素にタプルをとることができます。

        \d-code(```
          utop # ((1, "one"), 1) ;;
          - : (int * string) * int = ((1, "one"), 1)
        ```);%

        上記の例は、int型とstring型のタプル（\codem{(int \* string)}）とint型を要素に持つタプルを表します。
      }
    >
    +section?:(`Pattern matching`){パターンマッチ}<
      +p{
        そもそも\dfn{パターン}とはなんでしょうか。
        OCamlにおいて、パターンは厳密には式ではなく、これまで紹介した型（int型、char型、string型、bool型、...）や
        \ref-section(`Tuple`);のtuple型、変数などの要素の並びを確かめるものです。
        パターンはそれ単体で成り立つものではなく、後述する構文や一部の機能として利用されます。
        以降でこのパターンの具体的な利用方法についても見ていきます。        
      }
      +subsection?:(`Let binding pattern support`){letバインディングにおけるパターン}<+p{
        letバインティングは、パターンの利用をサポートしています。
        パターンは、以下の構文で表現されます。

        \d-code(```
          (<variable>, ...)
        ```);%

        \codem{\<variable\>}は変数名を表し、それに続く3つのドット（\codem{...}）は
        「後ろに2番目の変数、3番目の変数...のように0個以上の変数を取って良い」ことを示します。
        パターンで用いるこの変数を\dfn{パターン変数}といいます。
        letバインディングでは、パターンを以下のように利用できます。

        \d-code(```
          let (<variable>, ...) = <expr>
        ```);%

        上記の構文は、\codem{\<expr\>}が返すtuple型の要素をパターン\codem{(\<variable\>, ...)}にマッピングすることを示しています。
        ここで、\codem{\<expr\>}が返すtuple型の要素数とパターンである\codem{(\<variable\>, ...)}の変数の数が一致する必要があることに注意して下さい。

        以下にletバインディングにおけるパターンの利用例を示します。

        \d-code(```
          utop # let (x, y) = (1, "one") ;;
          val x : int = 1
          val y : string = "one"

          utop # x ;;
          - : int = 1

          utop # y ;;
          - : string = "one"
        ```);%

        上記の例では、タプル\codem{(1, "one")}の各要素を、変数\codem{x}及び\codem{y}にバインドしています。
        変数\codem{x}にはタプルの1番目の要素である\codem{1}がバインドされ、
        変数\codem{y}にはタプルの2番目の要素である\codem{"one"}がバインドされていることがわかります。
        このように、パターンを用いることで一度に変数を定義することができます。

        最後に、パターン変数の数とタプルの要素数が一致しない場合はエラーとなることに注意して下さい、

        \d-code(```
          utop # let (x, y) = (1, "one", 3.14) ;;
          Line 1, characters 13-29:
          Error: This expression has type 'a * 'b * 'c
                 but an expression was expected of type 'd * 'e
        ```);%

        上記のエラーは「式\codem{(1, "one", 3.14)}は3つの要素を持つtuple型\codem{'a \* 'b \* 'c}を返すが、（パターンは2つの変数しかないため）2つの要素を持つtuple型\codem{'d \* 'e}が期待された」ことが示されています。
        復習になりますが、\codem{'a,'b,'c,'d,'e}のように\codem{'}がついたものは型変数であり、
        これは「どのような型に属してもよい」つまり「任意の型を当てはめてよい」性質を持つものだったことを思い出して下さい。
      }>
      +subsection?:(`Match expression`){match式}<+p{
        if式は条件部分にbool型を取ることで条件分岐を行い、then節及びelse節のどちらか一方を実行するものでしたが、
        より複雑なパターンやそれに応じた分岐を扱いたい場合もあります。
        より複雑なパターンに対応するには、\dfn{match}式を利用します。
        OCamlでは、match式の利用を\dfn{パターンマッチ}または\dfn{パターンマッチング}といいます。

        パターンマッチは以下の構文を利用します。

        \d-code(```
          match <expr0> with
          | <pattern1> -> <expr1>
          | ...
        ```);%

        この構文は、まず\codem{\<expr0\>}を評価し、その結果を\codem{\<pattern\>}\footnote{
          構文中には\codem{\<pattern\>}という表現は出現しておらず\codem{\<pattern1\>}という表現のみ出現していますが、
          条件分岐のためのパターンを区別したいため、便宜上\codem{\<pattern1\>}としています。
        }と照合します。
        パターンは上から順に評価され、もし一致するパターンがあれば、その右辺にある\codem{\<expr\>}を評価します。
        \codem{\|}は「または」を意味します。
        また、各パターンの\codem{-\>}の右辺にある\codem{\<expr\>}は、全て同じ型を返す必要があります。
        これは、if式のthen、else節の\codem{\<expr\>}が同じ型を返さなければいけないことと同じです。
        パターンマッチを利用した例を以下に示します。

        \d-code(```
          utop # match (1, 2) with
            | (x, y) -> x + y ;;
          - : int = 3
        ```);%

        上記の例は、tuple型である\codem{(1,2)}に対してパターンマッチを適用し、
        タプルの1番目の要素である\codem{1}をパターン中の\codem{x}に、タプルの2番目の要素である\codem{2}をパターン中の\codem{y}に
        バインドし、最後に\codem{x + y}を実行した結果を返します。
        match式において、\codem{(x, y)}がパターン変数に該当します。
        また、パターンマッチを関数に組み込んで利用することもできます。

        \d-code(```
          utop # let add tuple = match tuple with
            | (x, y) -> x + y ;;
          val add : int * int -> int = <fun>
        ```);%

        上記の例では、インタプリタが\codem{add}という名前の関数を定義しています。
        関数\codem{add}は引数として\codem{int \* int}型のタプルをとります。
        以降の処理は前述したものと同じで、タプルの要素をパターン変数である\codem{x}及び\codem{y}にバインドし、
        最後に\codem{x + y}の結果を返します。
        関数の型は\codem{int \* int -\> int}であり、
        2つのint型の要素を持つタプルを引数にとり、その結果としてint型を返すことが分かります。
      }
      +p{
        また、letバインディングのパターンと一致しますが、関数\codem{add}の引数である\codem{tuple}は必ず2つの整数を要素として持つ必要があります。
        これは、パターンが\codem{(x, y)}となっており、必ず2つの要素と照合するようになっているためです。
        このことは、関数の型からも読み取ることができ、
        関数の型\codem{int \* int -\> int}において引数の型が\codem{int \* int}となっていることからも2つの整数の要素が必要であることが分かります。
      }
      +p{
        先程定義した関数は以下のように利用できます。

        \d-code(```
          utop # add (3, 4) ;;
          - : int = 7
        ```);%

        また、OCamlでは引数にパターンを書くこともでき、次のような定義も可能です。

        \d-code(```
          utop # let add (x, y) = x + y ;;
          val add : int * int -> int = <fun>

          utop # add (3, 4) ;;
          - : int = 7
        ```);%

        関数内でパターンマッチを利用した例と同じ結果が得られました。
      }
      +p{
        次に、match式におけるパターンの注意点を説明します。
        例えば、同じ値のペアを取得したいからといって、以下のようにパターンを書くことはできません。

        \d-code(```
          utop # let double tuple = match tuple with
            | (x, x) -> x + x ;;
          Line 2, characters 8-9:
          Error: Variable x is bound several times in this matching
        ```);%

        上記の例の作者は、関数\codem{double}はタプルを受け取るのですが、そのタプルの値が同じであることを期待していました\footnote{
          関数の名前的に、タプルの要素を2倍にしたかったのでしょう。
        }。

        しかしながら、エラーを読むと「パターン変数\codem{x}が複数回バインドされている」ことが分かります。        
        このように、同じ名前のパターン変数を利用することはできず、
        これはmatch式に限らず、letバインディングにおけるパターンの利用であっても同じです。
        以下は、letバインディングにて同じ名前のパターン変数を利用しようとして、エラーとなった例です。

        \d-code(```
          utop # let (x, x) = (1, "one") ;;
          Line 1, characters 8-9:
          Error: Variable x is bound several times in this matching
        ```);%

        パターンはあくまで並びや配置に関してのみ利用できます。
        同時に、パターン変数はお互いに異なる変数名である必要があります。
        そのため、上記の1つ目の例を正しく動作させるためには、

        \d-code(```
          utop # let double tuple = match tuple with
            | (x, y) -> x + y ;;
          val double : int * int -> int = <fun>
        ```);%

        のようにお互いに異なるパターン変数名にするか、2倍にしたいという作者の意図を汲むのであれば、

        \d-code(```
          utop # let double x = x * 2 ;;
          val double : int -> int = <fun>
        ```);%

        で良いかも知れません。
      }
      +p{
        また、パターンマッチにおいていづれか\footnote{
          「いづれ」は歴史的仮名遣いで、基本的に現代仮名遣いである「いずれ」を用いることが多いわけですが、
          個人的に見た目が好きなのと発音した時の意識が「いづれ」であるため、あえて使わせて下さい（笑）。
        }のパターン変数を利用しないケースも考えられます。
        例えば、タプルの最初の要素の値を返す関数を作ることを考えます。
        これまでの知識を利用して、以下のように関数を定義できます。

        \d-code(```
          utop # let return_first tuple = match tuple with
            | (x, y) -> x ;;
          val return_first : 'a * 'b -> 'a = <fun>

          utop # return_first (1, "one");;
          - : int = 1
        ```);%

        これは期待通りに動作しますが、パターン変数\codem{y}を利用していません。
        利用しない変数を定義してしまうのはムダですし、思わぬバグの原因ともなりえます。

        そこで、パターン変数には「どんな値にもマッチする且つパターン変数にバインドしない」ための
        \dfn{ワイルドカードパターン}があり、これはアンダースコア（\codem{_}）で表されます。
        ワイルドカードパターンに用いられるアンダースコア（\codem{_}）は、
        \codem{-\>}の右にある式中で参照することはできないため、
        利用しないパターン変数をワイルドカードパターンで置き換えることは良い考えです。

        ワイルドカードパターンを利用すると、上記の関数は以下のように定義できます。

        \d-code(```
          utop # let return_first tuple = match tuple with
            | (x, _) -> x ;;
          val return_first : 'a * 'b -> 'a = <fun>
        ```);%
      }
      +p{
        最後に、match式がif式よりも複雑な条件分岐を行える例を紹介します。

        ここでは、整数を文字列に変換する関数\codem{int_to_string}を考えてみます。
        任意の整数を文字列に変換するためは（今まで紹介した知識では）膨大なプログラムを書く必要があるため、
        ここでは1から3までの整数を変換することにします。
        if式を利用して、以下のように関数を定義できます。

        \d-code(```
          utop # let int_to_string i =
            if i = 1 then "one" else
              if i = 2 then "two" else
                if i = 3 then "three"
                else "NaN" ;;
          val int_to_string : int -> string = <fun>

          utop # int_to_string 1 ;;
          - : string = "one"
          utop # int_to_string 2 ;;
          - : string = "two"
          utop # int_to_string 3 ;;
          - : string = "three"
          utop # int_to_string 4 ;;
          - : string = "NaN"
        ```);%

        if式を用いた場合、上記のように\codem{else}節にさらにif式をネストさせることで複雑な条件分岐に対応できます。
        しかしながら、式全体の構造に読みにくさを感じます。
        そこで、match式を利用して、より読みやすい形で定義します。

        \d-code(```
          utop # let int_to_string i = match i with
            | 1 -> "one"
            | 2 -> "two"
            | 3 -> "three"
            | _ -> "NaN" ;;
          val int_to_string : int -> string = <fun>

          utop # int_to_string 1 ;;
          - : string = "one"
          utop # int_to_string 2 ;;
          - : string = "two"
          utop # int_to_string 3 ;;
          - : string = "three"
          utop # int_to_string 4 ;;
          - : string = "NaN"
        ```);%

        ずっと読みやすくなった気がします。
        さらに、ワイルドカードパターンを用いることで、1、2、3以外の整数が与えられた場合は\codem{"NaN"}と表示するようにしており、
        「想定する値以外は〇〇する」という意図が伝わりやすい表現になっているかと思います。
        このように、複雑な条件分岐を扱いたい場合はmatch式の利用を検討してみると良いでしょう。
      }
      +p{
        ここまで読んで、「あれ？パターンって\codem{(...)}のようなタプルの見た目をしたものだと思っていたのに、
        \ref-subsection(`Match expression`);で\codem{\| 整数 -\> ...}っていう表現が出てきて混乱してきた」
        と思われた方もいるのではないでしょうか。
        パターンとは、あくまで対象となる型や変数の並びを表したものであり、何か特定の表現ではないことに注意して下さい。
      }>
    >
    +section?:(`Practice of pattern matching`){実践}<
      +p{
    }>
>